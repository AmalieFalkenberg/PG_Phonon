/*******************************************************************************
*
*  McStas, neutron ray-tracing package
*  Copyright(C) 2000 Risoe National Laboratory.
*
* %I
* Written by: Kim Lefmann
* Date: 18.01.2024
* Origin: NBI, KU
*
* A sample for phonon scattering based on cross section expressions from Squires, Ch.3.
* based upon component Phonon_simple
* Using the Born-von Karman calculations
* 
* %D
* Single-cylinder shape.
* Absorption included.
* No multiple scattering.
* No incoherent scattering emitted.
* No attenuation from coherent scattering. No Bragg scattering.
* Specialized for PG
*
* Algorithm:
* 0. Always perform the scattering if possible (otherwise ABSORB)
* 1. Choose direction within a focusing solid angle
* 2. Select a phonon mode at random
* 3. Calculate the zeros of (E_i-E_f-hbar omega(kappa)) as a function of k_f
* 4. Choose one value of k_f (always at least one is possible!)
* 5. Perform the correct weight transformation
*
* %P
* INPUT PARAMETERS:
* radius: [m]         Outer radius of sample in (x,z) plane
* yheight: [m]        Height of sample in y direction
* sigma_abs: [barns]  Absorption cross section at 2200 m/s per atom
* sigma_inc: [barns]  Incoherent scattering cross section per atom
* DW: [1]             Debye-Waller factor
* T: [K]              Temperature
* focus_r: [m]        Radius of sphere containing target.
* focus_xw: [m]       horiz. dimension of a rectangular area
* focus_yh: [m]       vert.  dimension of a rectangular area
* focus_aw: [deg]     horiz. angular dimension of a rectangular area
* focus_ah: [deg]     vert.  angular dimension of a rectangular area
* target_x: [m]       position of target to focus at . Transverse coordinate
* target_y: [m]       position of target to focus at. Vertical coordinate
* target_z: [m]       position of target to focus at. Straight ahead.
* target_index: [1]   relative index of component to focus at, e.g. next is +1 
* mode_input: [1]     order of the phonon mode to be scattered (unphysical). In the range 0 through 11 . If mode_input == 12, then the mode is choosen at random
* verbose_input: [1]        toggles verbose mode (verbose>1) or eigenvector mode (verbose==1)
* dispersion: [1]   calculate and output the dispersion
*
* OUTPUT PARAMETERS:
* V_rho: [AA^-3]      Atomic density
* V_my_s: [m^-1]      Attenuation factor due to incoherent scattering
* V_my_a_v: [m^-1]    Attenuation factor due to absorbtion
*
* %L
* The test/example instrument <a href="../examples/Test_Phonon.instr">Test_Phonon.instr</a>.
*
* %E
******************************************************************************/

DEFINE COMPONENT Phonon_BvK_PG_eigenvector
DEFINITION PARAMETERS ()
SETTING PARAMETERS (hh=0,kk=0,ll=0,radius,yheight,sigma_abs=0,sigma_inc=0,DW=1,T,
focus_r=0,focus_xw=0,focus_yh=0,focus_aw=0,focus_ah=0,target_x=0, target_y=0, target_z=0, int target_index=0, int mode_input, int e_steps_low, int e_steps_high, int verbose_input=0, int dispersion=0)
OUTPUT PARAMETERS (q_x, q_y, q_z)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */
SHARE
%{
#ifndef PHONON_SIMPLE
#define PHONON_SIMPLE $Revision$
#define T2E (1/11.605)   /* Kelvin to meV */
#define SMALL_NUMBER 1E-6
#define V_HIGH 8000   // Highest velocity to search` (TO BE CHANGED)
#define MATRIX_TEST 0 // Change to 1 to write matrices to disk
#define TIME_EIGENSYSTEMS 1
#pragma acc routine 


// CONSTANTS
#define pi    3.14159265358979323846264338327950288419716939937510L
#define sqrt3 1.73205080756887729352744634150587236694280525381038L  
#define DIM 12  
    
#define DV 0.001   // Velocity change used for numerical derivative 

    
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
//#include "/usr/include/linux/types.h"// Change from Mads: On OS X this path is not valid
#include"cnr.h"
//#include <malloc.h>
#include <stdlib.h> 

#include "../src/eigen.h"
   
    extern FILE *matrix_test_file, *parms_test_file;
    extern int matrix_test_count;
    int mode,verbose;


double nbose(double omega, double T)  /* Other name ?? */
  {
    double nb;

    nb= (omega>0) ? 1+1/(exp(omega/(T*T2E))-1) : 1/(exp(-omega/(T*T2E))-1);
    return nb;
  }
#undef T2E
/* Routine types from Numerical Recipies book */
#define UNUSED (-1.11e30)
#define MAXRIDD 60

void fatalerror_cpu(char *s)
  {
    fprintf(stderr,"%s \n",s);
    exit(1);
  }
 
#pragma acc routine 
void fatalerror(char *s)
  {
  #ifndef OPENACC	
    fatalerror_cpu(s);
  #endif
  }

  #pragma acc routine

void bubblesort (int size , double* inputarray , int* index)
//this function modifies the inputarray by bubble sorting, and also modifies the index array as the
//index after the sorting. The index array should be initialized as index[] = {0,1,2,3,4,5,6,7...}
{
    int tempindex = 0;
    int i;
    int j;
    for (i = 0 ; i < size-1 ;  i++)
    {
        for (j = 0 ; j < size-1 ; j++)
        {
            if (inputarray[index[j]] > inputarray[index[j+1]])
            {
                tempindex = index[j];
                index[j] = index[j+1];
                index[j+1] = tempindex;
            }
        }
     }
    return;
}



/* TODO: Det er meget langsomt at bruge pointere. Erstat med flad memory. */
//3*3 matrices multiplication
void matrixmultiplication( double matrix1[3][3], double matrix2[3][3], double result[3][3])
    {
        // multiplies matrix1 by matrix2 and places the result in result
//      double matrix1[3][3]={{*(array1), *(array1+1), *(array1+2)}, {*(array1+3), *(array1+4), *(array1+5)}, {*(array1+6), *(array1+7), *(array1+8)}};
//      double matrix2[3][3]={{*(array2), *(array2+1), *(array2+2)}, {*(array2+3), *(array2+4), *(array2+5)}, {*(array2+6), *(array2+7), *(array2+8)}};

      result[0][0]=matrix2[0][0]*matrix1[0][0]+matrix2[1][0]*matrix1[0][1]+matrix2[2][0]*matrix1[0][2];
      result[0][1]=matrix2[0][1]*matrix1[0][0]+matrix2[1][1]*matrix1[0][1]+matrix2[2][1]*matrix1[0][2];
      result[0][2]=matrix2[0][2]*matrix1[0][0]+matrix2[1][2]*matrix1[0][1]+matrix2[2][2]*matrix1[0][2];
      result[1][0]=matrix2[0][0]*matrix1[1][0]+matrix2[1][0]*matrix1[1][1]+matrix2[2][0]*matrix1[1][2];
      result[1][1]=matrix2[0][1]*matrix1[1][0]+matrix2[1][1]*matrix1[1][1]+matrix2[2][1]*matrix1[1][2];
      result[1][2]=matrix2[0][2]*matrix1[1][0]+matrix2[1][2]*matrix1[1][1]+matrix2[2][2]*matrix1[1][2];
      result[2][0]=matrix2[0][0]*matrix1[2][0]+matrix2[1][0]*matrix1[2][1]+matrix2[2][0]*matrix1[2][2];
      result[2][1]=matrix2[0][1]*matrix1[2][0]+matrix2[1][1]*matrix1[2][1]+matrix2[2][1]*matrix1[2][2];
      result[2][2]=matrix2[0][2]*matrix1[2][0]+matrix2[1][2]*matrix1[2][1]+matrix2[2][2]*matrix1[2][2];

      return;
    }

// TODO: Benchmark mod pointer-snask versioner: matrix3mupltiplication of matrixmultiplication
void matrix3x3_multiply3(const double A[9], const double B[9], const double C[9], double result[9])
{
  // R_{i,j} =  \sum_{k,l=1}^3 A_{i,k}*B_{k,l}*C_{l,j}
  for(int i=0;i<3;i++)
    for(int j=0;j<3;j++){
      double ij_sum = 0;
      for(int k=0;k<3;k++)
	for(int l=0;l<3;l++)
	  ij_sum += A[i*3+k]*B[k*3+l]*C[l*3+j];
      result[i*3+j] = ij_sum;
    }
}

/* TODO: Det er meget langsomt at bruge pointere. Erstat med flad memory. */ 
void matrix3multiplication(double matrix1[3][3], double matrix2[3][3], double matrix3[3][3], double result[3][3])
    {
        // Performs the multiplication (matrix1*matrix2)*matrix3 and placed the result in result
//#define TEST_MULTIPLY
        double temp[3][3];
        matrixmultiplication(matrix1,matrix2,temp);
        matrixmultiplication(temp,matrix3,result);
#ifdef TEST_MULTIPLY
        printf("Matrix3multiply called with \n");
        printf("matrix1 = (");
        for (int i=0; i<3; i++)
        {
            printf("( %g %g %g), ",matrix1[i][0], matrix1[i][1], matrix1[i][2]);
        }
        printf(")\n Matrix2 = (");
        for (int i=0; i<3; i++)
        {
            printf("( %g %g %g), ",matrix2[i][0], matrix2[i][1], matrix2[i][2]);
        }
        printf(")\n Matrix3 = (");
                for (int i=0; i<3; i++)
        {
            printf("( %g %g %g), ",matrix3[i][0], matrix3[i][1], matrix3[i][2]);
        }
        printf(")\n Temp = (");
                for (int i=0; i<3; i++)
        {
            printf("( %g %g %g), ",temp[i][0], temp[i][1], temp[i][2]);
        }
        printf(")\n Result = (");
                 for (int i=0; i<3; i++)
        {
            printf("( %g %g %g), ",result[i][0], result[i][1], result[i][2]);
        }
        printf(")\n");
#endif // TEST_MULTIPLY

        return;
    }
    

/* TODO: Erstat med standard complex.h operation */
komplex complexexp (double* q, double* rj)
{
//    double qrjtest
    double qrj = *(q)**(rj)+*(q+1)**(rj+1)+*(q+2)**(rj+2);
//    printf(" q= (%g %g %g), r = (%g %g %g) qrj = %g \n",q[0],q[1],q[2],rj[0],rj[1],rj[2],qrj);
    return cos(qrj)+I*sin(qrj);
}

    // _________________ INITIALIZE VARIABLES omega_q ___________________________
#define a_latt 2.461 //PG lattice constant in AA  paper gives 2.45
#define c_latt 6.708 // PG lattice constant in AA  paper gives 6.70
#define b_length 6.646 // PG scattering legth in fm
#define THz2meV 4.13566
#define Da2kg 1.6605e-27 //Dalton to kg converter
#define dyn2N 1e-3 //Convert dyn/cm to N/m
 
    double M = 12.011 * Da2kg; //atomic mass of C

#define K_l1  3.62e+5      // Force constant longitudinal nn1 - in (a,b) plane; here units of dyn
#define K_t1  1.99e+5      // Force constant transverse nn1 - in (a,b) plane
#define K_l2  1.33e+5      // Force constant longitudinal nn2 - in (a,b) plane
#define K_t2 -0.520e+5     // Force constant transverse nn2 - in (a,b) plane
#define K_l3 -0.037e+5     // Force constant longitudinal nn3 - in (a,b) plane
#define K_t3  0.288e+5     // Force constant transverse nn3 - in (a,b) plane
#define K_l4  0.058e+5     // Force constant longitudinal nn4 - along c
#define K_t4  0.0077e+5    // Force constant transverse nn4 - along c

// #define TEST_MATRICES

    
    //Lattice basis
    
    // PG is hexagonal close packed with 4 atoms per cell
    // Coordinates from the paper Fig. 7: Atoms A, B, C, D
    double Delta[4*3] = {0 , 0 , 0 , a_latt/(2*sqrt3) , a_latt/2 , 0 , 0 , 0 , c_latt/2 ,  -a_latt/(2*sqrt3) , a_latt/2 , c_latt/2};

    // Lattice vectors from paper fig. 7
    double avec[3] = {a_latt*sqrt3/2 , a_latt*0.5 , 0}; // THIS IS NEVER USED ??!!
    double bvec[3] = {a_latt*(-sqrt3/2) , a_latt*0.5 , 0};
    double cvec[3] = {0 , 0 , c_latt};

    // reciprocal lattice vectors
    double astar = 4*PI/(sqrt3*a_latt);  // length of reciprocal lattice vector a*
    double cstar = 2*PI/c_latt;  // length of reciprocal lattice vector c*

    // Rotation matrices
    double Rot120[3][3] = {{-0.5 , sqrt3/2 , 0} , {-sqrt3/2 , -0.5 , 0} , {0 , 0 , 1}};
    double Rot60[3][3] = {{0.5 , sqrt3/2 , 0} , {-sqrt3/2 , 0.5 , 0} , {0 , 0 , 1}};
    double Rot120rev[3][3] = {{-0.5 , -sqrt3/2 , 0} , {sqrt3/2 , -0.5 , 0} , {0 , 0 , 1}}; //rotate -120
    double Rot60rev[3][3] = {{0.5 , -sqrt3/2 , 0} , {sqrt3/2 , 0.5 , 0} , {0 , 0 , 1}}; //rotate -60
    double Rot180[3][3] = {{-1, 0, 0}, {0, -1, 0}, {0, 0, 1}}; // rotate 180 or -180
//    double Rot5[3][3] = {{0.5 , sqrt3/2 , 0} , {-sqrt3/2 , 0.5 , 0} , {0 , 0 , 1}}; //rotate 60
//    double Rot5rev[3][3] = {{0.5 , -sqrt3/2 , 0} , {sqrt3/2 , 0.5 , 0} , {0 , 0 , 1}}; //rotate -60
    
    //1st neighbour
    
//    double r_j1[3][3] = {{-a_latt/sqrt3 , 0 , 0} , {a_latt*0.5/sqrt3 , -a_latt*0.5 , 0} , {a_latt*0.5/sqrt3 , a_latt*0.5 , 0}}; // This holds from atoms A and D
//    double r_j2[3][3] = {{a_latt/sqrt3 , 0 , 0} , {-a_latt*0.5/sqrt3 , a_latt*0.5 , 0} , {-a_latt*0.5/sqrt3 , -a_latt*0.5 , 0}}; // This holds from atoms B and C

    double Phi_nn1[3][3] = {{K_l1*dyn2N , 0 , 0} , {0 , K_t1*dyn2N , 0} , {0 , 0 , K_t1*dyn2N}};

    double Phi1[3][3] = {{K_l1*dyn2N , 0 , 0} , {0 , K_t1*dyn2N , 0} , {0 , 0 , K_t1*dyn2N}}; //Phi1 = Phi_nn1

    double Phi2[3][3];

    double Phi3[3][3];
    
     
    //2nd neighbour
//    double r_j11[9][3] = {{a_latt*(-1/sqrt3) , 0 , 0} , {a_latt*0.5/sqrt3 , a_latt*(-0.5) , 0} , {a_latt*0.5/sqrt3 , a_latt*0.5 , 0} , {0 , a_latt , 0} , {-a_latt*sqrt3/2 , a_latt/2 , 0} , {-a_latt*sqrt3/2 , -a_latt/2 , 0} , {0 , -a_latt , 0} , {a_latt*sqrt3/2 , -a_latt/2 , 0} , {a_latt*sqrt3/2 , a_latt/2 , 0}};//r_j1 + r_add
//    double r_j21[9][3] = {{-a_latt*(-1/sqrt3) , -a_latt*0 , 0} , {-a_latt*0.5/sqrt3 , -a_latt*(-0.5) , 0} , {-a_latt*0.5/sqrt3 , -a_latt*0.5 , 0} , {0 , a_latt , 0} , {-a_latt*sqrt3/2 , a_latt/2 , 0} , {-a_latt*sqrt3/2 , -a_latt/2 , 0} , {0 , -a_latt , 0} , {a_latt*sqrt3/2 , -a_latt/2 , 0} , {a_latt*sqrt3/2 , a_latt/2 , 0}};//r_j2 + r_add
    
    double Phi_nn2[3][3] = {{K_t2*dyn2N , 0 , 0} , {0 , K_l2*dyn2N , 0} , {0 , 0 , K_t2*dyn2N}};
    double Phi4[3][3] = {{K_t2*dyn2N , 0 , 0} , {0 , K_l2*dyn2N , 0} , {0 , 0 , K_t2*dyn2N}};
    double Phi5[3][3];
    
    double Phi6[3][3];
        
    double Phi7[3][3];

    double Phi8[3][3];
     
    double Phi9[3][3];

    //3rd neighbour
//    double r_j12[12][3] = {{a_latt*(-1/sqrt3) , 0 , 0} , {a_latt*0.5/sqrt3 , a_latt*(-0.5) , 0} , {a_latt*0.5/sqrt3 , a_latt*0.5 , 0} , {0 , a_latt , 0} , {-a_latt*sqrt3/2 , a_latt/2 , 0} , {-a_latt*sqrt3/2 , -a_latt/2 , 0} , {0 , -a_latt , 0} , {a_latt*sqrt3/2 , -a_latt/2 , 0} , {a_latt*sqrt3/2 , a_latt/2 , 0} , {2*a_latt/sqrt3 , 0 , 0} , {-a_latt/sqrt3 , a_latt , 0} , {-a_latt/sqrt3 , -a_latt , 0}};//r_j11 + r_add2
    double r_j2[12][3] = {{a_latt/sqrt3 , 0 , 0} , {-a_latt*0.5/sqrt3 , a_latt*0.5 , 0} , {-a_latt*0.5/sqrt3 , -a_latt*0.5 , 0} , {0 , a_latt , 0} , {-a_latt*sqrt3/2 , a_latt/2 , 0} , {-a_latt*sqrt3/2 , -a_latt/2 , 0} , {0 , -a_latt , 0} , {a_latt*sqrt3/2 , -a_latt/2 , 0} , {a_latt*sqrt3/2 , a_latt/2 , 0} , {-2*a_latt/sqrt3 , 0 , 0} , {a_latt/sqrt3 , -a_latt , 0} , {a_latt/sqrt3 , a_latt , 0}};//r_j21 - r_add2

     
    double Phi_nn3[3][3] = {{K_l3*dyn2N , 0 , 0} , {0 , K_t3*dyn2N , 0} , {0 , 0 , K_t3*dyn2N}};

    // c2 = 2/sqrt(6);
    // c1 = 1/sqrt(6);
    // c0 = 1/sqrt(2);
    // c3 = 1/sqrt(3);

    double Phi10[3][3] = {{K_l3*dyn2N , 0 , 0} , {0 , K_t3*dyn2N , 0} , {0 , 0 , K_t3*dyn2N}}; //Phi_nn3;

    double Phi11[3][3];
    
    double Phi12[3][3];
    
    //4th neighbour
    double r_j13[14][3] = {{-a_latt/sqrt3 , 0 , 0} , {a_latt*0.5/sqrt3 , -a_latt*0.5 , 0} , {a_latt*0.5/sqrt3 , a_latt*0.5 , 0} , {0 , a_latt , 0} , {-a_latt*sqrt3/2 , a_latt/2 , 0} , {-a_latt*sqrt3/2 , -a_latt/2 , 0} , {0 , -a_latt , 0} , {a_latt*sqrt3/2 , -a_latt/2 , 0} , {a_latt*sqrt3/2 , a_latt/2 , 0} , {2*a_latt/sqrt3 , 0 , 0} , {-a_latt/sqrt3 , a_latt , 0} , {-a_latt/sqrt3 , -a_latt , 0} , {0 , 0 , c_latt/2} , {0 , 0 , -c_latt/2}};//r_j12 + r_add3 Sublattice B and D do not have this coupling

    double Phi_nn4[3][3] = {{K_t4*dyn2N , 0 , 0} , {0 , K_t4*dyn2N , 0} , {0 , 0 , K_l4*dyn2N}};
     
    double Phi13[3][3] = {{K_t4*dyn2N , 0 , 0} , {0 , K_t4*dyn2N , 0} , {0 , 0 , K_l4*dyn2N}}; //Phi_nn4;
    double Phi14[3][3] = {{K_t4*dyn2N , 0 , 0} , {0 , K_t4*dyn2N , 0} , {0 , 0 , K_l4*dyn2N}}; //Phi_nn4;
    
    
    // _______________ END INITIALIZE omega_q ___________________________
 
void initialize_omega_q()
{
    // Make the matrix algebra that finilizes the force constant set-up
    
    matrix3multiplication(Rot120,Phi_nn1,Rot120rev,Phi2); //Rot2*Phi_nn1*Rot2^(-1) 
    matrix3multiplication(Rot120rev,Phi_nn1,Rot120,Phi3);
    matrix3multiplication(Rot60,Phi_nn2,Rot60rev,Phi5);
    matrix3multiplication(Rot120,Phi_nn2,Rot120rev,Phi6); //Rot6*Phi_nn2*Rot6^(-1);
    matrix3multiplication(Rot180,Phi_nn2,Rot180,Phi7);    //Rot7*Phi_nn2*Rot7^(-1);
    matrix3multiplication(Rot120rev,Phi_nn2,Rot120,Phi8); //Rot8*Phi_nn2*Rot8^(-1);
    matrix3multiplication(Rot60rev,Phi_nn2,Rot60,Phi9);    //Rot9*Phi_nn2*Rot9^(-1);
    matrix3multiplication(Rot120,Phi_nn3,Rot120rev,Phi11);  //Rot11*Phi_nn3*Rot11^(-1);
    matrix3multiplication(Rot120rev,Phi_nn3,Rot120,Phi12); //Rot12*Phi_nn3*Rot12^(-1);
    
    return;

}
    
    double omega_q(komplex* parms, komplex* eigenvectorgood) {
    
    // _______________ DETERMINE Q ____________________________
    
      double vi, vf, vv_x, vv_y, vv_z, vi_x, vi_y, vi_z;
      double q, qx, qy, qz, Jq, hw_phonon, hw_neutron;
      double h,k,l;
      int disp;

// #define ASSERT_NONANS_COMPLEX(A,n) for(int ii=0;ii<n;ii++) if(isnan(creal(A[ii]) || isnan(cimag(A[ii])))){ fprintf(stderr,"Array " #A " contains a nan at position %d.\n",ii); abort(); }
      
//       ASSERT_NONANS_COMPLEX(parms,8);

      for(int ii=0;ii<8;ii++) if(isnan(creal(parms[ii])) || isnan(cimag(parms[ii]))){
	  fprintf(stderr,"omega_q: Array parms contains a nan at position %d.\n",ii);
	  fprintf(stderr,"parms = ["); for(int i=0;i<8;i++) fprintf(stderr,"%g + i%g%s",creal(parms[i]), cimag(parms[i]), i+1<8?", ":"]\n");
	  abort();
	}

      //      fprintf(stderr,"omega_q: no NaN's\n");      
      vf=parms[0];
      vi=parms[1];
      vv_x=parms[2];
      vv_y=parms[3];
      vv_z=parms[4];
      vi_x=parms[5];
      vi_y=parms[6];
      vi_z=parms[7];
      h = parms[9];
      k = parms[10];
      l = parms[11];
      disp = (int)parms[12];

 
      qx=V2K*(vi_x-vf*vv_x);
      qy=V2K*(vi_y-vf*vv_y);
      qz=V2K*(vi_z-vf*vv_z);
    
      if (disp==1) /* calculate dispersion directly */
      {
          printf("Dispersion calculation: ");
          qx = h*astar;
          qy = k*astar;
          qz = l*cstar;
      }
      
    double qvec[3]={qx,qy,qz};

    
    if (verbose>=3)
        printf("Enter omega_q; q = (%g, %g, %g) \n",qx,qy,qz);
    
    // ________________ END DETERMINE Q ________________-
    

    /* TODO: Det er meget langsommere med pointere. Erstat med flad memory. [3][3] -> [9] over alt.*/
    /* TODO: Ryd op og streamline! Pænere OG hurtigere. */
    komplex Phi_diag[3][3];
    int i;
    int j;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            Phi_diag[i][j] = Phi1[i][j]+Phi2[i][j]+Phi3[i][j]+Phi4[i][j]*(1-(*complexexp)(&qvec[0], &r_j13[3][0]))+Phi5[i][j]*(1-(*complexexp)(&qvec[0], &r_j13[4][0]))+Phi6[i][j]*(1-(*complexexp)(&qvec[0], &r_j13[5][0]))+Phi7[i][j]*(1-(*complexexp)(&qvec[0], &r_j13[6][0]))+Phi8[i][j]*(1-(*complexexp)(&qvec[0], &r_j13[7][0]))+Phi9[i][j]*(1-(*complexexp)(&qvec[0], &r_j13[8][0]))+Phi10[i][j]+Phi11[i][j]+Phi12[i][j];
        }
    }
    
    komplex Phi_diag1[3][3];
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            Phi_diag1[i][j] = Phi13[i][j]+Phi14[i][j];
        }
    }
    
    komplex Phi_offdiag1[3][3];
    komplex Phi_offdiag2[3][3];
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            Phi_offdiag1[i][j] =-Phi1[i][j]*((*complexexp)(&qvec[0], &r_j13[0][0]))-Phi2[i][j]*((*complexexp)(&qvec[0], &r_j13[1][0]))-Phi3[i][j]*((*complexexp)(&qvec[0], &r_j13[2][0]))-Phi10[i][j]*((*complexexp)(&qvec[0], &r_j13[9][0]))-Phi11[i][j]*((*complexexp)(&qvec[0], &r_j13[10][0]))-Phi12[i][j]*((*complexexp)(&qvec[0], &r_j13[11][0]));
            Phi_offdiag2[i][j] = conj(Phi_offdiag1[i][j]);
        }
    }
    
    komplex Phi_6Dim[6][6];
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            Phi_6Dim[i][j] = Phi_diag[i][j]+Phi_diag1[i][j];
            Phi_6Dim[i][j+3] = Phi_offdiag1[i][j];
            Phi_6Dim[i+3][j] = Phi_offdiag2[i][j];
            Phi_6Dim[i+3][j+3] = Phi_diag[i][j];  // Because Phi_diag1 does not appear for the B,C, sublattices
        }
    }
    
    komplex Phi_AC[3][3];
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            Phi_AC[i][j] = -Phi13[i][j]*((*complexexp)(&qvec[0], &r_j13[12][0]))-Phi14[i][j]*((*complexexp)(&qvec[0], &r_j13[13][0]));
        }
    }
    
    komplex Zero_3Dim[3][3] = {{0 , 0 , 0},{0 , 0 , 0},{0 , 0 , 0}};

    komplex Phi_6Dim_offdiag[6][6];
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            Phi_6Dim_offdiag[i][j] = Phi_AC[i][j];
            Phi_6Dim_offdiag[i][j+3] = Zero_3Dim[i][j];
            Phi_6Dim_offdiag[i+3][j] = Zero_3Dim[i][j];
            Phi_6Dim_offdiag[i+3][j+3] = Zero_3Dim[i][j];
        }
    }

    komplex Phi_12Dim[12][12];
    for (i = 0; i < 6; i++) {
        for (j = 0; j < 6; j++) {
            Phi_12Dim[i][j] = Phi_6Dim[i][j];
            Phi_12Dim[i][j+6] = Phi_6Dim_offdiag[i][j];
            Phi_12Dim[i+6][j] = conj(Phi_6Dim_offdiag[i][j]);
            Phi_12Dim[i+6][j+6] = Phi_6Dim[i][j];
        }
    }
    
#ifdef TEST_MATRICES
    printf("Phi_12Dim=\n");
    for (i = 0; i < 12; i++) {
      for (j = 0; j< 12; j++) {
	if (j == 0) {
	  printf("{");
	}
	printf("%g+(%g)i  ", real(Phi_12Dim[i][j]) , imag((Phi_12Dim[i][j])));
	if (j == 11) {
	  printf("}\n");
	}
      }
    }
    
    printf("Phi_6Dim=\n");
    for (i = 0; i < 6; i++) {
      for (j = 0; j< 6; j++) {
	if (j == 0) {
	  printf("{");
	}
	printf("%g+(%g)i  ", real(Phi_6Dim[i][j]) , imag((Phi_6Dim[i][j])));
	if (j == 5) {
	  printf("}\n");
	}
      }
    }

    printf("Phi_diag=\n");
    for (i = 0; i < 3; i++) {
      for (j = 0; j< 3; j++) {
	if (j == 0) {
	  printf("{");
	}
	printf("%g+(%g)i  ", real(Phi_diag[i][j]) , imag((Phi_diag[i][j])));
	if (j == 2) {
	  printf("}\n");
	}
      }
    }
    printf("Phi2={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}}\n",Phi2[0][0],Phi2[0][1],Phi2[0][2],Phi2[1][0],Phi2[1][1],Phi2[1][2],Phi2[2][0],Phi2[2][1],Phi2[2][2]);
    printf("Phi3={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi3[0][0],Phi3[0][1],Phi3[0][2],Phi3[1][0],Phi3[1][1],Phi3[1][2],Phi3[2][0],Phi3[2][1],Phi3[2][2]);
    printf("Phi5={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi5[0][0],Phi5[0][1],Phi5[0][2],Phi5[1][0],Phi5[1][1],Phi5[1][2],Phi5[2][0],Phi5[2][1],Phi5[2][2]);
    printf("Phi6={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi6[0][0],Phi6[0][1],Phi6[0][2],Phi6[1][0],Phi6[1][1],Phi6[1][2],Phi6[2][0],Phi6[2][1],Phi6[2][2]);
    printf("Phi7={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi7[0][0],Phi7[0][1],Phi7[0][2],Phi7[1][0],Phi7[1][1],Phi7[1][2],Phi7[2][0],Phi7[2][1],Phi7[2][2]);
    printf("Phi8={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi8[0][0],Phi8[0][1],Phi8[0][2],Phi8[1][0],Phi8[1][1],Phi8[1][2],Phi8[2][0],Phi8[2][1],Phi8[2][2]);
    printf("Phi9={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi9[0][0],Phi9[0][1],Phi9[0][2],Phi9[1][0],Phi9[1][1],Phi9[1][2],Phi9[2][0],Phi9[2][1],Phi9[2][2]);
    printf("Phi11={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi11[0][0],Phi11[0][1],Phi11[0][2],Phi11[1][0],Phi11[1][1],Phi11[1][2],Phi11[2][0],Phi11[2][1],Phi11[2][2]);
    printf("Phi12={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi12[0][0],Phi12[0][1],Phi12[0][2],Phi12[1][0],Phi12[1][1],Phi12[1][2],Phi12[2][0],Phi12[2][1],Phi12[2][2]);
    printf("Phi14={{%lf,%lf,%lf},{%lf,%lf,%lf},{%lf,%lf,%lf}\n}",Phi14[0][0],Phi14[0][1],Phi14[0][2],Phi14[1][0],Phi14[1][1],Phi14[1][2],Phi14[2][0],Phi14[2][1],Phi14[2][2]);

    printf(" 1-exp(q.r_j13[3]) = %lf + i %lf \n",real(1-(*complexexp)(&qvec[0], &r_j13[3][0])),imag(1-(*complexexp)(&qvec[0], &r_j13[3][0])));
    printf(" 1-exp(q.r_j13[4]) = %lf + i %lf \n",real(1-(*complexexp)(&qvec[0], &r_j13[4][0])),imag(1-(*complexexp)(&qvec[0], &r_j13[4][0])));
    printf(" 1-exp(q.r_j13[5]) = %lf + i %lf \n",real(1-(*complexexp)(&qvec[0], &r_j13[5][0])),imag(1-(*complexexp)(&qvec[0], &r_j13[5][0])));
    printf(" 1-exp(q.r_j13[6]) = %lf + i %lf \n",real(1-(*complexexp)(&qvec[0], &r_j13[6][0])),imag(1-(*complexexp)(&qvec[0], &r_j13[6][0])));
    printf(" 1-exp(q.r_j13[7]) = %lf + i %lf \n",real(1-(*complexexp)(&qvec[0], &r_j13[7][0])),imag(1-(*complexexp)(&qvec[0], &r_j13[7][0])));
    printf(" 1-exp(q.r_j13[8]) = %lf + i %lf \n",real(1-(*complexexp)(&qvec[0], &r_j13[8][0])),imag(1-(*complexexp)(&qvec[0], &r_j13[8][0])));
    
#endif // TEST_MATRICES
    
  double eigenvalue[DIM]; 
  komplex Q[DIM*DIM];
  komplex matrix[DIM*DIM];
  int index[DIM];
  
  
  for (i=0; i<DIM; i++)
    for (j=i; j<DIM; j++){
      matrix[i*DIM+j] = Phi_12Dim[i][j];
      matrix[j*DIM+i] = conj(matrix[i*DIM+j]);
    }

#if MATRIX_TEST
    fwrite(matrix,sizeof(komplex),DIM*DIM,matrix_test_file);
    fwrite(parms, sizeof(komplex),8,    parms_test_file);
#endif  
  

 eigensystem_hermitian(matrix, DIM, eigenvalue, Q); /* Produces unitary transformation matrix Q: eigenvectors are columns */

   for (i=0; i<DIM; i++)  index[i]=i;

  if (verbose >= 6)
  {
      printf("Before bubblesort\n");
      for (i=0; i<DIM; i++)
      {
          printf("i = %i eigenvalue[i] = %g index[i] %i \n",i,eigenvalue[i],index[i]);
      }
  }
  // Sort eigenvalues from lowest to highest
  //mergesort(eigenvalue,DIM,index);  

  bubblesort(DIM, eigenvalue, index);
  if (verbose >= 5)
  {
      printf("After bubblesort\n");
      for (i=0; i<DIM; i++)
      {
          printf("i = %i eigenvalue[i] = %g index[i] %i \n",i,eigenvalue[i],index[i]);
      }
  }   

  double eigenvaluegood[DIM];
  
    for (j = 0; j < DIM ; j++){
      eigenvectorgood[j] = Q[index[mode]*DIM + j]; /* Eigenvectors are columns of Q */ // No, they are rows!
    }

      if (verbose>=7)
      {
          printf("Q = [");
          for (i = 0; i < DIM ; i++)
          {
              printf("\n (");
              for (j=0; j<DIM; j++)
                  printf(" %g +i %g, ",real(Q[i*DIM+j]),imag(Q[i*DIM+j]));
              printf(")");
          }
          printf("]\n");
      }

      for (i=0; i<DIM; i++)
        eigenvaluegood[i] = sqrt(real(eigenvalue[index[i]]))/sqrt(M)/(2*PI*1E12)*THz2meV; // convert to units of THz    
	
  

    if (verbose>=5)
    {
        printf("Diagonalization done, eigenvalues (energies) are: \n (");
        for (i=0; i<DIM; i++)
            printf(" %g, ",eigenvaluegood[i]);
        printf(" )\n");
        printf("mode = %i , eigenvectorgood[mode] = (",mode);
        for (j=0; j<DIM; j++)
            printf(" %g +i %g, ",real(eigenvectorgood[j]),imag(eigenvectorgood[j]));
        printf(" )\n");
    }

        
  // ___________________ RETURN RESULTS TO CALLING FUNCTION __________________
  
  hw_neutron = fabs(VS2E*(vi*vi-vf*vf)); // neutron energy transfer 
  // fabs used to find both positive and negative solutions, controlled by findroots()  
      
  hw_phonon = eigenvaluegood[mode];  // phonon energy

  if(verbose >= 4){
    printf("Return from omega_q \n");
    printf("hw_neutron = %g (vi = %g, vf = %g)\n",hw_neutron, vi, vf);
    printf("hw_phonon  = %g = eigenvaluegood[%d] = %g = eigenvalues[%d] = %g\n",
	    hw_phonon,mode,eigenvaluegood[mode],index[mode], eigenvalue[index[mode]]);
//    printf("old parms  = ["); for(int i=0;i<8;i++) fprintf(stderr,"%g+i%g%s",creal(parms[i]), cimag(parms[i]), i+1<8?", ":"]\n");
  }
  
  parms[8] = hw_phonon;
  
  if (disp==1) {
      printf("mode = %d, (h,k,l) = (%g,%g,%g), hw_q = %g",mode,h,k,l,hw_phonon);
      printf(" polarization: (%g + i %g , %g + i %g , %g + i %g) \n",real(eigenvectorgood[0]),imag(eigenvectorgood[0]),real(eigenvectorgood[1]),imag(eigenvectorgood[1]), real(eigenvectorgood[2]),imag(eigenvectorgood[2]));
  }
  
// if (abs(hw_phonon - hw_neutron) < SMALL_NUMBER)
//      printf("q = ( %g , %g , %g ), q_abs = ( %g %g %g),  hw_q = %g \n",qx/astar,qy/astar,qz/cstar,qx,qy,qz,hw_phonon);

  return (hw_phonon - hw_neutron);
}

    // ------------------START OF THE DIAGONALIZATION CODE--------------------

#define SIGN_CONTROLLED(a,b) ((b)<0 ? -fabs(a) : fabs(a))
//#define TEST_DIAGONALIZE
//#define TEST_DIAGONALIZE_LV2
//#define FIND_EIGENSTATE



void nrerror(const char *error_text){
  printf("Numerical Recipes run-time error ...\n");
  printf("%s\n",error_text);
  printf("... now exiting to system.\n");
  exit(1);
}

double last_fh, last_x2;

double zridd(double (*func)(komplex*,komplex*), double x1, double x2, komplex *parms, komplex* vector, double xacc)
    {
      int j;
      double ans, fh, fl, fm, fnew, s, xh, xl, xm, xnew;

      //      fprintf(stderr,"i zridd(%g,%g, parms,%g)\n",x1,x2,xacc);
      parms[0]=x1;
      //      fprintf(stderr,"zridd fl = omega_q\n");      
      if (xacc>0)
      {
          fl=(*func)(parms,vector);
      }
      else
      {
          fl = last_fh;
          xacc = -xacc;
          if (abs(x1-last_x2)>xacc) 
              printf("*** error in zridd *** x1: %g last_x2: %g \n",x1,last_x2);
      }
      //      fprintf(stderr,"fl = %g\n",fl);                  
      parms[0]=x2;
      //      fprintf(stderr,"zridd fh = omega_q; parms[0] = x2 = %g+i%g = %g\n",creal(parms[0]), cimag(parms[0]),x2);
      last_fh=fh=(*func)(parms,vector);
      last_x2 = x2;
      //      fprintf(stderr,"fh = %g\n",fh);            
      if (fl*fh >= 0)
      {
        if (fl==0) return x1;
        if (fh==0) return x2;
        return UNUSED;
      }
      else
      {
        xl=x1;
        xh=x2;
//        printf("zridd sign change: v_low : %g v_high: %g \n",xl,xh);
        ans=UNUSED;
        for (j=1; j<MAXRIDD; j++)
        {
          xm=0.5*(xl+xh);
          parms[0]=xm;
	  //	  fprintf(stderr,"zridd fm = omega_q\n");	  
          fm=(*func)(parms,vector);
          s=sqrt(fm*fm-fl*fh);
          if (s == 0.0)
            return ans;
          xnew=xm+(xm-xl)*((fl >= fh ? 1.0 : -1.0)*fm/s);
          if (fabs(xnew-ans) <= xacc)
            return ans;
          ans=xnew;
          parms[0]=ans;
	  //	  fprintf(stderr,"s = %g;  fl, fm, fh = %g,%g,%g; fnew = %g; fm*fm-fl*fh = %g\n",
	  //		  s, fl, fm,fh, fnew, fm*fm-fl*fh);
	  //fprintf(stderr,"zridd fnew = omega_q\n");
          fnew=(*func)(parms,vector);
          if (fnew == 0.0) return ans;
          if (fabs(fm)*SIGN(fnew) != fm)
          {
            xl=xm;
            fl=fm;
            xh=ans;
            fh=fnew;
          }
          else
            if (fabs(fl)*SIGN(fnew) != fl)
            {
              xh=ans;
              fh=fnew;
            }
            else
              if(fabs(fh)*SIGN(fnew) != fh)
              {
                xl=ans;
                fl=fnew;
              }
              else
                fatalerror("never get here in zridd");
          if (fabs(xh-xl) <= xacc)
            return ans;
        }
        fatalerror("zridd exceeded maximum iterations");
      }
      return 0.0;  /* Never get here */
    }

#pragma acc routine 
double zridd_gpu(double x1, double x2, komplex *parms, komplex* vector, double xacc)
    {
      int j;
      double ans, fh, fl, fm, fnew, s, xh, xl, xm, xnew;

      parms[0]=x1;
      //      fprintf(stderr,"fl=omega_q(%g+i%g)\n",creal(parms[0]),cimag(parms[0]));                  
      fl=omega_q(parms,vector);
      parms[0]=x2;
      //      fprintf(stderr,"fh=omega_q(%g+i%g)\n",creal(parms[0]),cimag(parms[0]));                  
      fh=omega_q(parms,vector);
      if (fl*fh >= 0)
      {
        if (fl==0) return x1;
        if (fh==0) return x2;
        return UNUSED;
      }
      else
      {
        xl=x1;
        xh=x2;
        ans=UNUSED;
        for (j=1; j<MAXRIDD; j++)
        {
          xm=0.5*(xl+xh);
          parms[0]=xm;
	  //	  fprintf(stderr,"fm=omega_q(%g+i%g)\n",creal(parms[0]),cimag(parms[0]));            	  
          fm=omega_q(parms,vector);
          s=sqrt(fm*fm-fl*fh);
          if (s == 0.0)
            return ans;
          xnew=xm+(xm-xl)*((fl >= fh ? 1.0 : -1.0)*fm/s);
          if (fabs(xnew-ans) <= xacc)
            return ans;
          ans=xnew;
          parms[0]=ans;
	  //	  fprintf(stderr,"fnew=omega_q(%g+i%g)\n",creal(parms[0]),cimag(parms[0]));            	  
          fnew=omega_q(parms,vector);
          if (fnew == 0.0) return ans;
          if (fabs(fm)*SIGN(fnew) != fm)
          {
            xl=xm;
            fl=fm;
            xh=ans;
            fh=fnew;
          }
          else
            if (fabs(fl)*SIGN(fnew) != fl)
            {
              xh=ans;
              fh=fnew;
            }
            else
              if(fabs(fh)*SIGN(fnew) != fh)
              {
                xl=ans;
                fl=fnew;
              }
              else
                fatalerror("never get here in zridd");
          if (fabs(xh-xl) <= xacc)
            return ans;
        }
        fatalerror("zridd exceeded maximum iterations");
      }
      return 0.0;  /* Never get here */
    }

 
#define ROOTACC 1e-8

  int findroots(double brack_low, double brack_mid, double brack_high, double *list, int* index, double (*f)(komplex*,komplex*), komplex *parms, komplex* vector, int low_steps, int high_steps)
    {
      double root,range;
      int i;

     if (verbose==2)
          printf("Enter findroots() \n");
     
 // First, find roots in energy loss side, if any
     range = brack_mid-brack_low;
     for (i=0; i<(low_steps-1); i++) 
     {
        if (i==0)
           root = zridd(f, brack_low+range*i/low_steps,
                   brack_low+range*(i+1)/low_steps,
                   (komplex *)parms, (komplex *)vector, ROOTACC);
        else
           root = zridd(f, brack_low+range*i/low_steps,
                   brack_low+range*(i+1)/low_steps,
                   (komplex *)parms, (komplex *)vector, -ROOTACC);  // Re-use the previous fh value
      if (root != UNUSED)
      {
        list[(*index)++]=root;
        if (verbose >=3)
            printf("--- findroots returned a root on the energy loss side: vf = %g \n",root);
      }
     }
   
     range = (brack_mid-brack_low)/(double)low_steps;
     for (i=0; i<low_steps; i++)  // Small steps close to zero energy transfer
     {
         if (low_steps==1)  // then the previous loop did not execute
            root = zridd(f, brack_low+range*(low_steps-1+i/(double)low_steps),
                   brack_low+range*(low_steps-1+(i+1)/(double)low_steps),
                   (komplex *)parms, (komplex *)vector, ROOTACC);
        else
            root = zridd(f, brack_low+range*(low_steps-1+i/(double)low_steps),
                   brack_low+range*(low_steps-1+(i+1)/(double)low_steps),
                   (komplex *)parms, (komplex *)vector, -ROOTACC);  // Re-use the previous fh value  
      if (root != UNUSED)
      {
        list[(*index)++]=root;
        if (verbose >=3)
            printf("--- findroots returned a root on the energy loss side: vf = %g \n",root);
      }
     }

 // Second, find roots in energy gain side, there is always some
     range = (brack_high-brack_mid)/(double)high_steps;
     for (i=0; i<high_steps; i++) // Close to zero: small steps
     {
         if (i==0)
            root = zridd(f, brack_mid+range*i/(double)high_steps, 
                   brack_mid+range*(i+1)/(double)high_steps, 
                   (komplex *)parms, (komplex *)vector, ROOTACC);
        else
            root = zridd(f, brack_mid+range*i/(double)high_steps, 
                   brack_mid+range*(i+1)/(double)high_steps, 
                   (komplex *)parms, (komplex *)vector, -ROOTACC);  // Re-use the previous fh value
      if (root != UNUSED)
      {
        list[(*index)++]=root;
        if (verbose >= 3)
            printf("*** findroots returned a root on the energy gain side: vf = %g \n",root);
      }
     }
     
     range = brack_high-brack_mid;
     for (i=1; i<high_steps; i++)  // Larger steps away from zero
     {
      root = zridd(f, brack_mid+range*i/(double)high_steps, 
                   brack_mid+range*(i+1)/(double)high_steps, 
                   (komplex *)parms, (komplex *)vector, -ROOTACC);  // Re-use the previous fh value - there was always one
      if (root != UNUSED)
      {
        list[(*index)++]=root;
        if (verbose >= 3)
            printf("*** findroots returned a root on the energy gain side: vf = %g \n",root);
      }
     }
     
    }
  
#pragma acc routine 
  int findroots_gpu(double brack_low, double brack_mid, double brack_high, double *list, int* index, double *parms, komplex* vector, int low_steps, int high_steps)
    {
      double root,range=brack_mid-brack_low;
      int i;

     for (i=0; i<low_steps; i++)
     {
       root = zridd_gpu(brack_low+range*i/(int)low_steps,
                   brack_low+range*(i+1)/(int)low_steps,
                   (komplex *)parms, (komplex *)vector, ROOTACC);
      if (root != UNUSED)
      {
        list[(*index)++]=root;
      }
     } 
    for (i=0; i<high_steps; i++)
     {
      root = zridd_gpu(brack_mid+range*i/(int)high_steps,
                   brack_high+range*(i+1)/(int)high_steps,
                   (komplex *)parms, (komplex *)vector, ROOTACC);
       if (root != UNUSED)
      {
        list[(*index)++]=root;
      }
     }
    }
  
#undef UNUSED
#undef MAXRIDD
#endif
%}

//DEPENDENCY "../src/eigen.o"

DECLARE
%{
  double V_rho;
  double V_my_s;
  double V_my_a_v;
  komplex **Matrix;
  int i,j;
  double q[3];    /* Scattering vector */
  double qx;
  double qy;
  double qz;
  double q_x;
  double q_y;
  double q_z;
  komplex eigenvectormode[DIM];
  komplex p_call[15];  /* Parameter list to transfer to omega_q; elsewhere known as parms */ 
%}
INITIALIZE
%{
  V_rho = 4/(a_latt*a_latt*c_latt*sqrt3/2);  // (unit: Å^-3)
  V_my_s = (V_rho * 100 * sigma_inc);
  V_my_a_v = (V_rho * 100 * sigma_abs * 2200);

  /* now compute target coords if a component index is supplied */
  if (!target_index && !target_x && !target_y && !target_z) target_index=1;
  if (target_index){
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index), POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &target_x, &target_y, &target_z);
  }
  if (!(target_x || target_y || target_z)) {
    printf("Phonon_simple: %s: The target is not defined. Using direct beam (Z-axis).\n",
      NAME_CURRENT_COMP);
    target_z=1;
  }
  initialize_omega_q();
  
  /* Now fill global variables for functions */
        verbose = verbose_input;

%}
TRACE
%{
  double t0, t1;            /* Entry/exit time for cylinder */
  double v_i, v_f;          /* Neutron velocities: initial, final */
  double vx_i, vy_i, vz_i;  /* Neutron initial velocity vector */
  double dt0, dt;           /* Flight times through sample */
  double l_full;            /* Flight path length for non-scattered neutron */
  double l_i, l_o;          /* Flight path lenght in/out for scattered neutron */
  double my_a_i;            /* Initial attenuation factor */
  double my_a_f;            /* Final attenuation factor */
  double solid_angle;       /* Solid angle of target as seen from scattering point */
  double aim_x=0, aim_y=0, aim_z=1;   /* Position of target relative to scattering point */
  double omega;             /* Energy transfer */
  double qsquare;           /* Square of the scattering vector */
  double bose_factor;       /* Calculated value of the Bose factor */
  int nf, index;            /* Number of allowed final velocities */
  double vf_list[20];       /* List of allowed final velocities */
  double J_factor;          /* Jacobian from delta fnc.s in cross section */
  double f1, f2;            /* Probed values of omega_q minus omega */
  double p1,p2,p3,p4,p5;    /* Temporary multipliers */
  int i,j;
  
  if(cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, yheight))
  {
    //    fprintf(stderr,"intersect\n");      
    if(t0 < 0)
      ABSORB; /* Neutron came from the sample or begins inside */

    if (verbose>=2) 
        printf("neutron entered Phonon_BvK_PG \n");
    /* Neutron enters at t=t0. */
    dt0 = t1-t0;                /* Time in sample */
    v_i = sqrt(vx*vx + vy*vy + vz*vz);
    l_full = v_i * dt0;   /* Length of path through sample if not scattered */
    dt = rand01()*dt0;    /* Time of scattering (relative to t0) */
    l_i = v_i*dt;                 /* Penetration in sample at scattering */
    vx_i=vx;
    vy_i=vy;
    vz_i=vz;
    PROP_DT(dt+t0);             /* Point of scattering */

    aim_x = target_x-x;         /* Vector pointing at target (e.g. analyzer) */
    aim_y = target_y-y;
    aim_z = target_z-z;

    if(focus_aw && focus_ah) {
      randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
        aim_x, aim_y, aim_z, focus_aw, focus_ah, ROT_A_CURRENT_COMP);
    } else if(focus_xw && focus_yh) {
      randvec_target_rect(&vx, &vy, &vz, &solid_angle,
        aim_x, aim_y, aim_z, focus_xw, focus_yh, ROT_A_CURRENT_COMP);
    } else {
      randvec_target_sphere(&vx,&vy,&vz,&solid_angle,aim_x,aim_y,aim_z, focus_r);
    }
    NORM(vx, vy, vz);
    nf=0;
    if (mode_input == 12)
    {
        mode = round(12*rand01()-0.5); 
    }
    else
    {
        mode = mode_input;
    }
    if ((mode < 0) || (mode > 11))
    {
        printf("mode = %d ",mode);
        nrerror("illegal value of mode");
    }
    
      p_call[0]=-1;
      p_call[1]=v_i;
      p_call[2]=vx;
      p_call[3]=vy;
      p_call[4]=vz;
      p_call[5]=vx_i;
      p_call[6]=vy_i;
      p_call[7]=vz_i;
      p_call[9]=hh;
      p_call[10]=kk;
      p_call[11]=ll;
      p_call[12] = (double)dispersion;
      
      if (dispersion==1)
      {
          f1=omega_q(p_call,eigenvectormode);
          p_call[12]=0.0;
      }
      
    #ifndef OPENACC
    if (verbose >=2) 
        printf("Call findroots \n");      
    findroots(0, v_i, v_i+V_HIGH, vf_list, &nf, omega_q, p_call, eigenvectormode, e_steps_low, e_steps_high);
    if (verbose >=2)
        printf( "Findroots returned %d roots \n",nf);
    #else
    findroots_gpu(0, v_i, v_i+V_HIGH, vf_list, &nf, p_call, eigenvectormode, e_steps_low, e_steps_high);
    #endif

    if (verbose>=3)
    {
        printf("Findroots done, mode %i , last phonon energy %g \n",mode,real(p_call[8]));  
    }
    
    // ________________ ALL FROM HERE IS CALCULATION OF INTENSITY - SHOULD BE REVISITED ___________________
   
        index=(int)floor(rand01()*nf); // Select random solution
        v_f=vf_list[index];
        p_call[0]=v_f;      // transfer choice of v_f to omega_q

        f1=omega_q(p_call,eigenvectormode);
        if (verbose >= 2)
        {
            printf("Chosen solution is %i; v_f = %g, hw = %g, energy match is %g; eigenvector is: (", index, v_f, real(p_call[8]), f1);
            for (j=0; j<DIM; j++)
                printf(" %g +i %g, ",real(eigenvectormode[j]),imag(eigenvectormode[j]));
            printf(" )\n");
            printf("--------------------------------------------\n");
        }
      p_call[0]=v_f-DV;
      //      fprintf(stderr,"f1=omega_q(%g+i%g)\n",creal(p_call[0]),cimag(p_call[0]));            
      f1=omega_q(p_call,eigenvectormode);
      //      fprintf(stderr,"retur fra f1=omega_q\n");            
      p_call[0]=v_f+DV;
      //      fprintf(stderr,"f2=omega_q(%g+i%g)\n",creal(p_call[0]),cimag(p_call[0]));                  
      f2=omega_q(p_call,eigenvectormode);
      //      fprintf(stderr,"retur fra f2=omega_q\n");                  
      J_factor = fabs(f2-f1)/(2*DV); // Removed K2V, double check!
      omega=VS2E*(v_i*v_i-v_f*v_f);
      vx *= v_f;
      vy *= v_f;
      vz *= v_f;

      q_x=q[0]=V2K*(vx_i-vx);
      q_y=q[1]=V2K*(vy_i-vy);
      q_z=q[2]=V2K*(vz_i-vz);

      if (dispersion==1)
      {
          printf("Dispersion found:  (h,k,l) = (%g, %g, %g), hw = %g \n",q[0]/astar,q[1]/astar,q[2]/cstar,omega);
      }
      
      qsquare=1;
      
      komplex Fn = 0;
      komplex q_dot_e;
      double q_dot_r;
      for (i=0; i<4; i++) // loop over atoms in unit cell
      {
          q_dot_e = (komplex)0;
          q_dot_r = 0;
          for (j=0; j<3; j++) // loop over x,y,z
          {
              q_dot_e += (komplex)q[j]*eigenvectormode[3*i+j]; 
              q_dot_r += q[j]*Delta[3*i+j];
          }
          if (verbose >= 7)
          {
              printf("i = %i , q dot r = %g , q dot e = (%g + i %g) Fn contrib = (%g + i %g)",i,q_dot_r,real(q_dot_e),imag(q_dot_e),real(b_length*q_dot_e*eksp(I*q_dot_r)),imag(b_length*q_dot_e*eksp(I*q_dot_r)));
          }
          Fn += b_length*q_dot_e*eksp(I*q_dot_r);
      }
      if (verbose >= 7) 
          printf("\n");
      
      if(!cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, yheight))
	{
	  printf("FATAL ERROR: Did not hit cylinder from inside.\n");
	  exit(1);
	}
	
	if (verbose>=2)
        printf("neutron left Phonon_BvK_PG, p_init = %g,",p);
      dt = t1;
      l_o = v_f*dt;
      
      my_a_i = V_my_a_v/v_i;
      my_a_f = V_my_a_v/v_f;
      bose_factor=nbose(omega,T);
      p1 = exp(-(V_my_s*(l_i+l_o)+my_a_i*l_i+my_a_f*l_o)); /* Absorption factor (units: 1) */
      p2 = nf*solid_angle*l_full*V_rho/(4*PI);     /* Focusing factors; assume random choice of n_f possibilities (units: m/Å^3) */
      p3 = (v_f/v_i)*DW/fabs(omega)*bose_factor;   /* Cross section factor 1 (units: s) */
      p4 = 2*VS2E*v_f/J_factor;  /* Jacobian of delta functions in cross section */
      p5 = Fn*conj(Fn)/M;  /* Cross section factor 2. !!! TEST !!!  (units: fm^2 Å^2) */
      p *= p1*p2*p3*p4*p5;
      if (mode_input == 12)
          p *= 12;  //The factor 12 is due to MC choice between the 12 modes

      if (verbose>=2) 
        printf(" p1 = %g, p2= %g, p3 = %g, p4 = %g, p5 = %g, bose_factor = %g, p_final = %g\n",p1,p2,p3,p4,p5,bose_factor,p);
  } /* else transmit: Neutron did not hit the sample */
%}

MCDISPLAY
%{
  
  circle("xz", 0,  yheight/2.0, 0, radius);
  circle("xz", 0, -yheight/2.0, 0, radius);
  line(-radius, -yheight/2.0, 0, -radius, +yheight/2.0, 0);
  line(+radius, -yheight/2.0, 0, +radius, +yheight/2.0, 0);
  line(0, -yheight/2.0, -radius, 0, +yheight/2.0, -radius);
  line(0, -yheight/2.0, +radius, 0, +yheight/2.0, +radius);
%}

END
